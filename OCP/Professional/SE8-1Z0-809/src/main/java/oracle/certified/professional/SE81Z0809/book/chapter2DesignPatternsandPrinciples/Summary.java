package oracle.certified.professional.SE81Z0809.book.chapter2DesignPatternsandPrinciples;

public class Summary {
    /*
    One of the primary goals of this chapter was to teach you how to write better code.
    We demonstrated techniques for designing class structures that scale naturally over time,
        integrate well with other applications, and are easy for other developers to read and understand.

    We started off with a brief review of interfaces from your OCA studies showing how to declare,
    implement, and extend them.
    We then moved on to functional programming and reviewed the various syntax options available
        for defining functional interfaces and writing lambda expressions.
    Given the prevalence of lambda expressions throughout Java 8, you absolutely need to practice
        writing and using lambda expressions before taking the exam.

    We concluded the discussion with a review of the generics‐based Predicate interface and
        showed how it can be used in place of your own functional interface.
    We will return to lambdas and streams in Chapter 3 and Chapter 4 in much greater detail.

    This chapter introduced the concept of polymorphism,
        which is central to the Java language,
        and showed how objects can be accessed in a variety of forms.
    Make sure that you understand when casts are needed for accessing objects,
        and be able to spot the difference between compile‐time and runtime cast problems.

    In the design principles section,
        we taught you how to encapsulate your classes in Java properly,
        allowing you to enforce class invariants in your data model.
    We then described the is‐a and has‐a principles and showed how you can apply them to your data model.
    Finally,
        we introduced the technique of creating class structures using object composition
        that rely on the has‐a principle as an alternative to inheritance.

    We completed this chapter by explaining what a design pattern is
        and presenting you with four well‐known design patterns.
    Design patterns provide you with a way to solve a problem that you encounter
        using solutions that other developers have already built and generalized.
    - The singleton pattern
    The singleton pattern is excellent for managing a single shared instance of an object
        within an application.
   - The immutable object pattern
   The immutable object pattern is useful for creating read‐only objects
        that cannot be modified by other classes.
   - The builder pattern
   The builder pattern solves the problem of how to create complex objects cleanly,
        and it is often used in conjunction with the immutable object pattern.
   Finally,
   - The factory pattern
   The factory pattern is useful for creating various objects
        without exposing the underlying constructors
        and complex rules for selecting a particular object subtype.
     */
}
